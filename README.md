
# CDM (customizable data management) system

Настраиваемая система управления данными

## Для участвующих в разработке

Посмотри [contributing.md](./contributing.md) для вклада в разработку системы.

## Для разработчиков front-end части системы

Посмотри [macaques.md](./macaques.md). Здесь расположена информация о `/dev` роутах

## Установка и запуск

Установите зависимости и запустите проект после конфигурирования необходимых файлов. 

```bash
  npm install
  npm run start:new
```

В дальнейшем, если модели данных не были изменены, то для запуска нужна команда:

```bash
  npm start
```

При изменении моделей необходимо сделать новый билд приложения через команду:

```bash
  npm run start:new
```

*Примечение*: запуск `start:new` делает новый билд приложения и **удаляет старую базу данных**! Поэтому, для стандатного запуска приложения нужно запускать `start`.

## Создание своего приложения

Папка для конфигурирования приложения имеет название "src".

Она состоит из:

- папки "Models" - в ней хранятся файлы с классами описывающими модели данных;
- файл "Scope" - где, в перечислении, находятся названия классов моделей.

### Описание модели
Создайте свою модель в папке "Models". 

#### Пример:
Предположим, что мы конфигурируем приложение под нужды учёта книг для Библиотеки:
```
@ModelConfig()
class Book extends Model {
  @Field({ type: FieldType.STRING })
  name: string | undefined;

  @Field({ type: FieldType.STRING })
  ISBN: string | undefined;
}
```
Класс создаваемой модели наследуется от класса в [./packages/models/Model.ts](./packages/models/Model.ts)

| Декоратор      | Парметры     | Описание                |
| :--------      | :------- | :------------------------- |
| `@ModelConfig` | `modelName` | Объявление модели данных |
| `@Field`       | `type, required, unique, defaultValue` | Объявление простого поля модели  |

### Описание связей
Создайте ещё одну модель в папке "Models".

#### Пример:
Это может быть модель отделения библиотеки, которое представляет какую-то группу книг одной направленности:
```
@ModelConfig()
export class Group extends Model {
  @Field({ type: FieldType.STRING })
  name: string | undefined;
  @HasMany({ model: Scope.Book })
  books: string | undefined;
}
```
В данном случае, мы хотим чтобы одно отделение библиотеки содержало множество книг. Поэтому, нам подходит связь "один ко многим". 
| Декоратор      | Парметры     | Описание                |
| :--------      | :------- | :------------------------- |
| `@HasOne` | `model` | Объявление связи один к одному |
| `@HasMany` | `model` | Объявление связи один ко многим |

Смысл записи для конкретного примера: группа (`class Group`) имеет много (`@HasMany`) книг (`model: Scope.Book`). Аналогичная логика и для декоратора `@HasOne`.

В объект параметра декоратора отношения передаётся не класс, а его название из перечисления `Scope`. Его также необходимо объявить (пример):
```
export enum Scope {
  Book,
  Group,
}
```

Здесь должны быть названия всех объявленных в папке `src/Models` моделей.

### Описание роутов
Для описания операций над той или иной моделью можно использовать декоратор `@RoutesConfig`.

#### Параметры `@RoutesConfig`
В аргументы декоратор принимает массив функций из папки [decorators/routes](./packages/decorators/routes/_constants.ts):
- `GET_ALL` - получить все записи
- `GET_ONE` - получить конкретную запись по id
- `CREATE` - создать запись
- `UPDATE` - обновить запись по id
- `DELETE` - удалить запись по id

В функции `CREATE` и `UPDATE` можно передать параметры с необходимыми полями для запроса. Это может быть полезно, например, если нужно разшить изменение лишь некоторых полей в запросе `UPDATE`.

**Примечание:** В дженерик декоратора стоит передать класс модели, для которой мы этот самый декоратор используем. Это определит тип передаваемых функций и их переменных.

#### Пример:
Предположим, нужно ограничить запросы с сущностью `Book` до запросов на получение и изменение:
```
@ModelConfig()
@RoutesConfig<Book>([GET_ALL(), GET_ONE(), UPDATE(["title"])])
class Book extends Model {
  @Field({ type: FieldType.STRING })
  title: string | undefined;

  @HasOne({ model: Scope.Author })
  author: string | undefined;
}
```
Передали в аргументы декоратора `@RoutesConfig` массив функций определённых типов запросов. Также, ограничили запрос на изменение данных в модели "Book".

В итоге, для примера сущности "Book" будут доступны следующие запросы:
- `GET_ALL` - получить все записи "Book"
- `GET_ONE` - получить конкретную запись "Book" по id
- `UPDATE` - обновить запись "Book" по id

## Файл входа
Приложение конфигурируется и запускается через функцию `AppConfigurator`.

```
AppConfigurator([Book, Group, Author], {
  serverPort: process.env.SERVER_PORT as any,
  database: {
    dialect: "postgres",
    host: process.env.DB_HOST as any,
    port: process.env.DB_PORT as any,
    username: process.env.DB_USER as any,
    password: process.env.DB_PASS as any,
    database: process.env.DB_NAME as any,
  },
});

```
Передаются следующие параметры:
- массив классов моделей
- конфигурационный объект

## Переменные окружения

Чтобы запустить проект, создайте файл `.env` в корне проекта

`DB_USER` - имя пользователя БД

`DB_PASS` - пароль БД

`DB_HOST` - хост БД

`DB_PORT` - порт БД

`DB_NAME` - имя БД

`SERVER_PORT` - порт для разворачивания сервера

## Документация к API сконфигурированной системы

Документация размащается по адресу `/api-docs`.

## Технологический стек

Node, Express, Sequileze, Swagger-UI

